/*
*
*   Device Mapper Proxy (dmp)
*    
*   Device mapper target that
*   creates a proxy device and counts some statistics
*    
*
*/

#include <linux/device-mapper.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/bio.h>
#include <linux/kobject.h>
#include <linux/average.h>


DECLARE_EWMA(avg_size, 4, 4);


/*
*
*   Structure for dmp-specific data
*
*/

struct dmp_data 
{
    struct dm_dev* dev;
};

static struct kobject* stat;

static struct statistics 
{
    u64 read_requests;
    u64 write_requests;    
    u64 total_requests;
    struct ewma_avg_size read_avg_blocksize;
    struct ewma_avg_size write_avg_blocksize;
    struct ewma_avg_size total_avg_blocksize;
} dmp_stats = {0, 0, 0, };



/*
*
*    Device mapper constuctor function
*    Called when block device of dmp type is created  
*    by 'dmsetup create' command
*
*/

static int device_mapper_proxy_ctr(struct dm_target* ti, unsigned int argc, char** argv)
{
    struct dmp_data* dmpd;
    int ret;

    //check arg count
    //there are only 1 argument - device name
    if (argc != 1) 
    {
        printk(KERN_CRIT "\n Invalid number of arguments.\n");
        ti->error = "Invalid argument count";
        return -EINVAL;
    }

    //allocate memory for dmp_data structure
    dmpd = kmalloc(sizeof(struct dmp_data), GFP_KERNEL);

    //check if allocation was successful
    if(dmpd == NULL)
    {
        printk(KERN_CRIT "\n\nDMPD pointer is NULL!\n\n");
        ti->error = "dmp: allocation failed (out of memory?)";
        return -ENOMEM;
    }
    
    //get underlying device from table and set its structure
    ret = dm_get_device(ti, argv[0], dm_table_get_mode(ti->table), &dmpd->dev);
    if (ret) 
    {
        ti->error = "dmp: Device lookup failed";
        goto bad;
    }

    //store dmp structure as target-specific data in dm_target
    ti->private = dmpd;

    return 0;

    bad:
    printk(KERN_CRIT "\n\n Device mapper proxy constuctor exited with error! \n\n");
    kfree(dmpd);
    return ret;
}


/*
*
*    Maps bio to underlying device
*    Called when device is removed
*
*/

static int device_mapper_proxy_map(struct dm_target* ti, struct bio* bio)
{
    struct dmp_data* dmpd;

    //total stats
    dmp_stats.total_requests += 1;
    ewma_avg_size_add(&dmp_stats.total_avg_blocksize, bio->bi_iter.bi_size); 

    //checking io type
    switch (bio_op(bio)) 
    {
    case REQ_OP_READ:
        //read
        dmp_stats.read_requests += 1;
        ewma_avg_size_add(&dmp_stats.read_avg_blocksize, bio->bi_iter.bi_size);
        break;
    case REQ_OP_WRITE:
        //write
        dmp_stats.write_requests += 1;
        ewma_avg_size_add(&dmp_stats.write_avg_blocksize, bio->bi_iter.bi_size);
        break;
    default:
        return DM_MAPIO_KILL;
    }

    //submit bio
    dmpd = (struct dmp_data*)ti->private;
    bio_set_dev(bio, dmpd->dev->bdev);
    submit_bio(bio);
    
    return DM_MAPIO_SUBMITTED;
}


/*
*
*    Device mapper destructor function 
*
*/

static void device_mapper_proxy_dtr(struct dm_target* ti)
{
    struct dmp_data* dmpd = (struct dmp_data*) ti->private;       
    dm_put_device(ti, dmpd->dev);
    kfree(dmpd);               
}


/*
*
*    Sysfs attribute access function
*    Fills buf using snprintf, limit output buffer size to PAGE_SIZE
*
*/

static ssize_t volumes_show(struct kobject* kobj, struct kobj_attribute* attr, char* buf)
{
    return snprintf(buf, PAGE_SIZE, "read:\n reqs: %llu\n avg size: %lu\nwrite:\n \
reqs: %llu\n avg size: %lu\ntotal:\n reqs: %llu\n avg size: %lu\n",
        dmp_stats.read_requests,
        (unsigned long)ewma_avg_size_read(&dmp_stats.read_avg_blocksize),
        dmp_stats.write_requests,
        (unsigned long)ewma_avg_size_read(&dmp_stats.write_avg_blocksize),
        dmp_stats.total_requests,
        (unsigned long)ewma_avg_size_read(&dmp_stats.total_avg_blocksize));
}


/*
*
*    Sysfs attribute struct generated by __ATTR macro
*    store func is NULL
*
*/

static struct kobj_attribute volumes_attr = __ATTR(volumes, 0644, volumes_show, NULL);


/*
*
*    target_type structure
*    describes a target parameters, sets contructor, mapper and destructor functions
*
*/

static struct target_type device_mapper_proxy = 
{    
    .name = "dmp",
    .version = {0,0,1},
    .module = THIS_MODULE,
    .ctr = device_mapper_proxy_ctr,
    .dtr = device_mapper_proxy_dtr,
    .map = device_mapper_proxy_map,
};


/*
*
*    Kernel moudle functions:
*
*/


/*
*
*    Register module or show message with error code
*
*/

static int device_mapper_proxy_init(void)
{
    //register new device mapper target
    int r = dm_register_target(&device_mapper_proxy);

    if (r < 0)
    {
        printk("register failed %d", r);
        return r;
    }

    //register and add new kernel object
    //follows example in linux src: linux/samples/kobject/kobject-example.c
    stat = kobject_create_and_add("stat", &THIS_MODULE->mkobj.kobj);
    if(!stat)
    {
        printk("failed to add kobject!");
        dm_unregister_target(&device_mapper_proxy);
        return -ENOMEM;
    }    
    
    //create sysfs attribute 
    r = sysfs_create_file(stat, &volumes_attr.attr);
    if (r < 0)
    {
        printk("failed to create sysfs entry!");
        dm_unregister_target(&device_mapper_proxy);
        kobject_put(stat);
        return r;
    }

    //init ewma
    ewma_avg_size_init(&dmp_stats.read_avg_blocksize);
    ewma_avg_size_init(&dmp_stats.write_avg_blocksize);
    ewma_avg_size_init(&dmp_stats.total_avg_blocksize);

    return 0;
}


/*
*
*    Exit module, and free its resources
*
*/

static void device_mapper_proxy_exit(void)
{
    dm_unregister_target(&device_mapper_proxy);
    kobject_put(stat);
}

module_init(device_mapper_proxy_init);
module_exit(device_mapper_proxy_exit);

MODULE_AUTHOR("Mikhail Motylenok <q3.inform@ya.ru>");
MODULE_DESCRIPTION(DM_NAME " proxy device counting some io statistics");
MODULE_LICENSE("GPL");